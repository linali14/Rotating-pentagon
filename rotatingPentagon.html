<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Rotating Pentagon</title>
    <!-- Load Tailwind CSS for simple, clean styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Three.js library for 3D graphics -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
      /* Ensure the canvas fills the container and sits in the center */
      #container {
        width: 100%;
        max-width: 800px;
        height: 500px;
        margin: 0 auto;
        border-radius: 1rem;
        box-shadow: 0 10px 15px rgba(0, 0, 0, 0.1);
        overflow: hidden;
        background-color: #e5e7eb; /* Light gray background for contrast */
      }
    </style>
  </head>
  <body class="bg-gray-100 min-h-screen p-4 flex flex-col items-center">
    <header class="text-center mb-6">
      <h1 class="text-3xl font-bold text-gray-800">
        Unit 2: WebGL Polygon Assignment
      </h1>
      <p class="text-gray-600">
        A 5-vertex polygon (pentagon) rendered in Three.js, rotating slowly on
        its axes, with a red surface.
      </p>
    </header>

    <!-- This div will contain the Three.js rendering canvas -->
    <div id="container" class="w-full"></div>

    <script>
      // --- Global Scene Variables ---
      let scene, camera, renderer, pentagon;

      /**
       * Initializes the Three.js scene, camera, and renderer.
       * This function sets up the basic environment for 3D rendering.
       */
      function init() {
        // 1. Scene Setup: The container for all objects, lights, and cameras.
        scene = new THREE.Scene();
        // Set the background color to a very light blue for visibility
        scene.background = new THREE.Color(0xf0f4f8);

        // 2. Camera Setup: Defines the viewing perspective.
        // PerspectiveCamera( fov, aspect, near, far )
        // fov: Field of View (45 degrees is standard)
        // aspect: Width / Height of the container
        // near/far: Clipping planes (objects outside this range are not rendered)
        const container = document.getElementById("container");
        const aspectRatio = container.clientWidth / container.clientHeight;
        camera = new THREE.PerspectiveCamera(75, aspectRatio, 0.1, 1000);
        camera.position.z = 5; // Move the camera back so we can see the object

        // 3. Renderer Setup: Responsible for drawing the scene onto the canvas.
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        // 4. Create the Polygon (Pentagon)
        createPentagon();

        // 5. Add subtle ambient light to make the surface visible
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);

        // 6. Add directional light for better shading and depth perception
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(2, 2, 5);
        scene.add(directionalLight);

        // Start the animation loop
        animate();
      }

      /**
       * Creates a 5-sided polygon (pentagon) geometry using custom vertices and indices.
       * This manually defines a mesh with exactly 5 vertices as required.
       */
      function createPentagon() {
        // Define a buffer geometry object. This is a highly efficient way to store
        // the geometry data for the GPU.
        const geometry = new THREE.BufferGeometry();

        // --- Define 5 Vertices for a Regular Pentagon ---
        // The vertices are calculated using trigonometry to form a flat, regular pentagon
        // centered at the origin (0, 0, 0) with a radius of 2 units.
        const radius = 2;
        const vertices = [];
        const sides = 5;

        // Loop 5 times (0 to 4) to define the X and Y coordinates of the 5 vertices
        for (let i = 0; i < sides; i++) {
          // Calculate the angle for the current vertex
          const angle = ((Math.PI * 2) / sides) * i;
          // X = radius * cosine(angle)
          const x = radius * Math.cos(angle);
          // Y = radius * sine(angle)
          const y = radius * Math.sin(angle);
          // Z = 0 (since it's a flat 2D polygon)
          const z = 0;

          // Push the coordinates in the order X, Y, Z
          vertices.push(x, y, z);
        }

        // Set the vertex positions for the geometry
        geometry.setAttribute(
          "position",
          new THREE.Float32BufferAttribute(vertices, 3)
        );

        // --- Triangulation using Indices (Element Buffer) ---
        // A pentagon (5 vertices) needs 3 triangles to form a solid face.
        // We pin the first vertex (index 0) and fan out the triangles from there.
        const indices = [
          0,
          1,
          2, // Triangle 1 (v0, v1, v2)
          0,
          2,
          3, // Triangle 2 (v0, v2, v3)
          0,
          3,
          4, // Triangle 3 (v0, v3, v4)
        ];
        geometry.setIndex(indices);

        // Recalculate normals for proper lighting and shading
        geometry.computeVertexNormals();

        // --- Define the Red or Blue Material (Requirement: Red Surface) ---
        const material = new THREE.MeshPhongMaterial({
          color: 0xff0000, // Red surface color (0xff0000)
          side: THREE.DoubleSide, // Render both sides of the polygon
          flatShading: true, // Gives a faceted, geometric look
        });

        // Combine the geometry and material into a Mesh object
        pentagon = new THREE.Mesh(geometry, material);
        scene.add(pentagon);
      }

      /**
       * The main animation loop.
       * This function is called repeatedly (~60 times per second) to update the scene
       * and redraw the content, creating the illusion of movement.
       */
      function animate() {
        // Requests the browser to call 'animate' again before the next repaint.
        requestAnimationFrame(animate);

        // --- Rotation Logic (Requirement: Spin slowly on axes) ---
        // Slowly rotate the polygon around the X-axis and Y-axis
        pentagon.rotation.x += 0.005;
        pentagon.rotation.y += 0.007;

        // Render the scene from the camera's perspective
        renderer.render(scene, camera);
      }

      /**
       * Handles window resizing to keep the scene responsive.
       */
      function onWindowResize() {
        const container = document.getElementById("container");
        const newWidth = container.clientWidth;
        const newHeight = container.clientHeight;

        // Update camera aspect ratio and projection matrix
        camera.aspect = newWidth / newHeight;
        camera.updateProjectionMatrix();

        // Update renderer size
        renderer.setSize(newWidth, newHeight);
      }

      // Attach the resize handler to the window event
      window.addEventListener("resize", onWindowResize);

      // --- Start the application on window load ---
      window.onload = init;
    </script>
  </body>
</html>
